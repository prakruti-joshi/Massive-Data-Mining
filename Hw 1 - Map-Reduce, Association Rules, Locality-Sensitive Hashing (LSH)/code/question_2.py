# -*- coding: utf-8 -*-
"""question_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gU4bEVRinhFbPOjRBxf5sebT--0rJpwJ
"""

import itertools

# To remove items from itemset whose count is less than support value

def prune_itemset(itemset, s):
  pruned_itemset = {k:v for k,v in itemset.items() if v >= s}
  return pruned_itemset

# To generate frequent pairs (whose count is greater than support s) from frequent single items 

def generate_k_frequent_items(frequent_itemset, baskets, s, k):

  if k > 2:
    freq_items = set([f for fp in frequent_itemset for f in fp])
  else:
    freq_items = frequent_itemset

  candidate_k_frequent = {}
  # k-item count subset from baskets
  for basket in baskets:
    basket_subset = []   # Containing only frequent itemsets
    for item in basket:
      if item in freq_items:
        basket_subset.append(item)
    basket_subset = sorted(basket_subset)
    k_items = itertools.combinations(basket_subset, k)  # k-item subset of frequent items in basket
    for item in k_items:
        if item in candidate_k_frequent:
          candidate_k_frequent[item] += 1
        else:
          candidate_k_frequent[item] = 1

  k_frequent_items = prune_itemset(candidate_k_frequent, s)
  return k_frequent_items

def confidence(a, b):
    return b/a

def generate_confidence_scores(itemset1, itemset2 , k):

  # Here,
  # itemset1 = dictionary representing frequent items of size k-1 and their counts
  # itemset2 = dictionary representing frequent items of size k and their counts

  c = []    # list of confidence pairs and their confidence scores

  if k == 2:
    for key, val in itemset2.items():
      c.append(((key[0], key[1]), confidence(itemset1[key[0]], val)))  # confidence(A->B)
      c.append(((key[1], key[0]), confidence(itemset1[key[1]], val)))  # confidence(B->A)
  else:
    for key, val in itemset2.items():
      # Generate k-1 subset combinations from k itemset
        i_subsets = itertools.combinations(key, k-1)
        for i_subset in i_subsets:
            if i_subset in itemset1:   
                c.append((tuple(list(i_subset) + list(set(key) - set(i_subset))), confidence(itemset1[i_subset], val)))
  return c

def main(support=100, r = 5):
  
  # r = number of top rules to be displayed

  # Input file
  input_file = 'browsing.txt'
  
  # Reading the input files into baskets and counting single items
  single_items = {}    # Dictionary of single items, Key:item  Value: count
  baskets = []    #  List of baskets

  with open(input_file, 'r') as f:
      for line in f:
          basket = line.strip().split(' ')
          if basket[0] == '':   # Check empty basket
              continue
          for item in basket:
              if item in single_items:
                  single_items[item] += 1
              else:
                  single_items[item] = 1
          baskets.append(set(basket))
  
  s = support  # Setting the support value
  frequent_single_items = prune_itemset(single_items, s)

  # Generating pairs from fequent single items
  frequent_pairs = generate_k_frequent_items(frequent_single_items, baskets,s,2)

  # Generate frequent triples from frequent pairs
  frequent_triples = generate_k_frequent_items(frequent_pairs, baskets,s,3)

  # Generate confidence scores of frequent itemsets of pairs
  fp_conf = generate_confidence_scores(frequent_single_items, frequent_pairs , 2)
  fp_conf.sort(key=lambda x: (-x[1], x[0]))
  print("Top 5 pairs and their confidence scores:")
  print("  A    ->    B       Confidence score")
  for p in fp_conf[:r]:
    print("{} -> {} {}".format(p[0][0], p[0][1], p[1]))

  print("")
  print("----------------------------------------------------------")
  print("")

  # Generate confidence scores of frequent itemsets of triplets
  ft_conf = generate_confidence_scores(frequent_pairs, frequent_triples , 3)
  ft_conf.sort(key=lambda x: (-x[1], x[0]))
  print("Top 5 triples and their confidence scores:")
  print("  (A,B)   ->   C     Confidence score")
  for t in ft_conf[:r]:
    print("{}, {} -> {} {}".format(t[0][0], t[0][1], t[0][2], t[1]))

main(100,5)

